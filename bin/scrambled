#!/usr/bin/env python3
"""
Print all derangements of the characters in a string.
Run with the --help option to see a help menu.

This example script tests some common tasks:

- Parse command-line arguments.
- Read default parameters from a file.
- Save outputs to a (possibly very large) file.
- Send log messages to STDOUT and errors to STDERR.

"""
from argparse import ArgumentParser
from itertools import permutations
from pathlib import Path

from pydiner import REPO, achtung, batched, echo, fullpath, getparams


OUTPUTS = REPO / "var"
PROFILES = REPO / "etc"


def argparams():
    """ dict: Parameters parsed from command-line inputs. """
    parsed = ArgumentParser()
    parsed.description = """Find all derangements of characters in WORD."""
    arg = parsed.add_argument
    arg("word", nargs="?", type=str, help="scramble this string")
    arg("-n", "--nbatch", type=int, help="maximum batch size")
    arg("-o", "--outpath", type=Path, help="save output to this file")
    arg("-p", "--profile", type=str, help="use pre-configured defaults")
    arg("-q", "--quiet", action="store_true", help="no log messages to STDOUT")
    parsed = parsed.parse_args()
    parsed = { k:v for k,v in vars(parsed).items() if v is not None }

    return parsed


def derangements(word):
    """
    Generator[str]: Permutations of word with no char in its original position.
    Outputs are unique if and only if word has no duplicated letters.
    Example: eggs -> ('gesg', 'gseg', 'gesg', 'gseg')
    """
    for perm in map("".join, permutations(sorted(word))):
        if not any(x == y for x, y in zip(perm, word)):
            yield perm


def factorial(n):
    """ int: n! if n is a non-negative integer """
    return n * factorial(n - 1) if (n > 1) else 1


def main(**kwargs):
    profile = PROFILES / kwargs.pop("profile", "default")

    echo("Read parameters from ", profile)
    params = getparams(profile, **kwargs)
    outpath = OUTPUTS / params.pop("outpath")
    nbatch = params.pop("nbatch")
    quiet = params.pop("quiet")
    word = params.pop("word")

    nlines = round(0.4 * factorial(len(word)))
    if not quiet:
        echo(f"Calculate approximately {nlines} derangements.")

    megalines = nlines // 1_000_000
    if megalines:
        achtung(f"Expected output is {megalines} million lines")

    echo(f"Write derangements of '{word}' to {outpath}")
    with open(outpath, "w") as file:
        for batch in batched(derangements(word), nbatch):
            print("\n".join(batch), file=file)


if __name__ == "__main__":
    main(**argparams())
